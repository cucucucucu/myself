目录
1 前言	1
2 总体方案设计	1
2.1 设计内容	1
2.2	方案比较与选择	2
2.2.1 信号产生	2
2.2.2 程控增益	2
2.2.3 人机交互	3
3 单元模块设计	3
3.1 主控芯片电路	3
3.2 AD9833外围电路	4
3.2.1 AD9833介绍	5
3.2.2 AD9833工作原理	5
3.2.3 AD9833频率和相位计算	6
3.2.4 时钟电路	7
3.3 程控增益电路	7
3.4 滤波电路	7
3.5 电源电路	8
3.6 系统连接	9
4 软件设计	10
4.1 主程序设计	10
4.2 主程序	11
4.3 串口中断处理	12
4.4 MCU应答程序	13
4.5 AD9833驱动程序	15
4.6 屏幕显示更新程序	17
5 系统功能、指标参数	18
5.1 系统功能	18
5.2 指标参数	18
5.2.1 频率	18
5.2.2 相位	19
5.2.3 幅值	20
6 结论	21
7 总结与体会	21
8 致谢	22
9 参考文献	23
附录一 相关设计图	24
附录二 相关设计软件	27
































1 前言
随着电子技术的发展，要求信号的频率越来越准确和越来越稳定，一般振荡器已不能满足系统设计的要求。晶体振荡器虽然具有高准确度和高稳定度，但其频率变化范围很小，而且频率值也不高，很难满足通信、雷达、测控、仪器电子系统的需求，这就需要应用频率合成技术来满足这一要求。
直接数字合成技术是美国学者于1971年提出的，即以全数字技术，从相位概念出发直接合成所需波形的一中新的频率合成原理，称之为直接数字频率合成器(Direct Digital Synthesis)。这是频率合成技术的一次重大革命。它的基本原理就是利用采样原理，通过查表法产生波形。但是限于当时微电子技术和数字信号处理技术的限制，DDS并没有得到足够的重视，随着现代超大规模集成电路集成工艺的高速发展，使得数字频率合成技术得到了质的飞跃，它在相对带宽、频率转换时间、相位连续性、正交输出、高分辨率以及集成化等一系列性能指标方面，已远远超过了传统频率合成技术所能达到的水平。但是由于DDS数字化实现的固有特点，决定了其输出频谱杂散较大。从20世纪80年代末开始通过深入的研究认识了DDS杂散成因及其分布规律后，对DDS相位累加器进行了改进，ROM数据进行了压缩，使用了抖动注入技术以及对DDS工艺结构和系统结构进行了改进。 
直接数字频率合成（DDS）技术继1971年问世以来，由于它低成本、低功耗、高分辨率、频率切换时间短、相位连续、相噪低、结构简单、体积小等诸多优点，在电信和电子仪器领域得到了越来越广泛的应用。AD9833是AD公司生产的一款采用DDS技术、低功耗、可编程波形发生器，器件采用MSOP封装，非常小巧，外围电路简单，通过SPI接口和单片机相连，编程可生成正弦波、三角波、方波，输出频率和相位都可通过软件编程，易于调节。 
本课题主要是基于DDS芯片AD9833的一款简易信号发生器，由STC15F2K60S2单片机通过3个SPI接口控制AD9833产生两路各种频率的正弦波、三角波、方波信号频率范围可以从0MHZ到10MHZ的稳定输出。后级通过高速运放THS3001进行幅值放大，且在输出端使用了12.5MHZ的五阶巴特沃斯无源滤波器进行滤波。整个系统通过串口与上位机相连，可以到达1HZ的步进。显示采用了HMI的串口通信显示屏，人机交互更加方便和简单。 
2 总体方案设计
2.1 设计内容
该系统以低功耗为出发点，用超低功耗单片机STC15F2K60S2作为主控芯片,选用低功耗芯片AD9833为信号产生芯片，采用了数字电位器MAX5487和高速运放THS3001实现幅度控制，使用触摸屏进行显示，通过串口与上位机进行通讯方便进行控制。且使用DDS器件，具有体积很小，电路简单的优点，整个系统可以做得很小，甚至可以作为手持设备使用，这就正好满足了当前技术的需要。此也为这次设计的几个创新点。
2.2	方案比较与选择
2.2.1 信号产生
方案一:采用FPGA实现直接数字频率合成器，将一定的采样点数将正弦波的一个周期存于rom表中，表中饱含一个周期正弦波的数字幅度信息，每个地址对应着0-360°范围内的相位点，然后通过查找表得到数据驱动D/A转换电路。缺点在于成本较高，实现频率较高时需要高速DA，相对不宜扩展。 
方案二: 采用MAX038高频波形产生器集成芯片，MAX038是精密高频波形产生器, 基本的振荡器是一个交变地以恒流向电容器充电和放电的驰张振荡器, 同时产生一个三角波和矩形波。通过改变COSC引脚的外接电容和流入IIN引脚的充放电电流的大小来控制输出信号频率, 频率范围为0.1～ 2MHz。缺点在于振荡频率的基频由RC振荡得来，不够精确不能进行精确的调制。而且频率较低失真度高
方案三:采用AD9833可编程波形发生器，能够产生正弦波、三角波和方波输出。输出频率和相位可通过软件进行编程，调整简单。无需外部元件。频率寄存器为28位；时钟速率为25 MHz，可以实现0.1 Hz的分辨率。AD9833通过一个三线式串行接口写入数据。
综合上面的方案考虑，最终选择了方案三。
2.2.2 程控增益
方案一:采用AD8376可编程增益放大器，AD8376是超低失真IF双通道VGA，700MHz的带宽，增益范围为-4dB至+20dB，步长：1dB。可以提供精密增益控制。该方案缺点是电路复杂，价格贵。
方案二:采用数字电位器MAX5487和高速运放THS3001。进行程控放大，MAX5487是一个8位带EEPROM的双通道的数字电位器，可实现0-255级可调。THS3001作为同相放大。闭环增益为420MHz，压摆率为6500-V/µs。输出电流达到100Ma。该方案价格低缺点在于只能逐级调节。
综合上面的方案考虑，最终选择了方案二。虽然方案二只能是实现逐级可调但是已经满足了一般需求
2.2.3 人机交互
方案一;采用LCD12864液晶显示屏分辨率为128*64，带汉字图形点阵液晶显示模块，可以显示8192个中文汉字、128个字符、以及64*256的点阵显示。这是一种常用的显示屏幕。缺点在于可视角度窄，显示不够美观。体积大
方案二:采用3.5寸HMI液晶触摸显示屏，分辨率高达480*320，支持多种组态控件：按钮控件、进度条控件、文本控件、指针控件等，上位软件自动升级、设备固件自动升级，自定义任意Windows字库，支持基本的GUI指令(画点、画线、画矩形等)，支持图片格式BMP、JPG、JPEG、PNG，支持串口下载和SD卡下载，支持模拟器和设备同步调试。实时的方便了开发。
综合上面的方案考虑，最终选择了方案二。虽然方案二只能是实现逐级可调但是已经满足了一般需求。
3 单元模块设计
3.1  主控芯片电路
STC15F2K60S2单片机是宏晶科技设计生产的单时钟/机器周期(1T)的单片机，是新一代8051单片机，指令代码完全兼容传统8051,但速度快6-12倍。内部集成高精度R/C时钟，5MHz～35MHz宽范围可设计，可彻底省掉外部昂贵的晶振。内部高可靠复位,8级可选复位门槛电压，可彻底省掉外部复位电路。最小系统如图3.1。
 ![这里写图片描述](http://img.blog.csdn.net/20160921214025670)
图3.1 单片机芯片STC15F2K60S2的最小系统
3.2 AD9833外围电路
AD9833是一个完全集成的直接数字频率合成(DDS)芯片。该芯片需要一个参考时钟、一个精密低电阻和多个去耦电容，用数字方式产生高达12.5MHz的正弦波。除产生这个RF信号之外，该芯片还完全能支持各种简单和复杂的调制方案。这些调制方案完全在数字域内实现，使得可以使用DSP技术精确而轻松地实现复杂的调制算法。AD9833的内部电路包含以下主要部分：数控振荡器 (NCO)、频率和相位调制器、SINROM、DAC以及稳压器。电路如图3.2所示。
 ![这里写图片描述](http://img.blog.csdn.net/20160921214350095)
图3.2 AD9833外围电路
3.2.1 AD9833介绍
AD9833是一个完全集成的直接数字频率合成(DDS)芯片。 该芯片需要一个参考时钟、一个精密低电阻和多个去耦电 容，用数字方式产生高达12.5 MHz的正弦波。除产生这个RF 信号之外，该芯片还完全能支持各种简单和复杂的调制方 案。这些调制方案完全在数字域内实现，使得可以使用 DSP技术精确而轻松地实现复杂的调制算法。 AD9833的内部电路包含以下主要部分：数控振荡器 (NCO)、频率和相位调制器、SIN ROM、DAC以及稳压器。
AD9833具有一个标准三线式串行接口，并且与SPI、QSPI™、 MICROWIRE®、DSP接口标准兼容。 
数据在串行时钟SCLK的控制下载入器件，16比特一个字。 这种操作的时序图见下。
 ![这里写图片描述](http://img.blog.csdn.net/20160921214405113)
图3.3 AD9833芯片内部结构
FSYNC输入是电平触发输入，用作帧同步和芯片使能。仅当FSYNC处于低电平时，才可将数据传输至器件。要开始 串行数据传输，应将FSYNC拉低，并注意FSYNC至SCLK下降沿建立时间t7的最小值。FSYNC变为低电平后，串行数据即会在16个时钟脉冲的SCLK下降沿移入器件的输入移位寄存器。可在SCLK的第16个下降沿后将FSYNC拉高，并注意SCLK下降沿至FSYNC上升沿时间t8的最小值。或者，FSYNC可以在16倍数个SCLK脉冲期间保持低电平，然后在 数据传输结束时变为高电平。这样，在FSYNC保持低电平 期间，可以连续流形式载入16位字；FSYNC仅在载入最后 一个字的第16个SCLK下降沿之后变为高电平。SCLK可以是连续的，也可以在写操作期间置于高电平或低电平空闲状态。无论何种情况，当FSYNC变为低电平(t11)时，SCLK都必须处于高电平。
3.2.2 AD9833工作原理
正弦波通常用其幅度来表示：a(t)=sin(ωt)。不过，这类正弦波是非线性曲线，因此除非通过分段构建，否则不易生成。另一方面，角度信息在本质上是线性的。也就是说，每个单位时间内，相位角度会旋转固定角度。角速率取决于信号频率，也即ω=2πf。
 
图3.4 DDS原理
已知正弦波的相位是线性的，如果给定参考时间间隔(时钟 周期)，则可以确定该周期内的相位旋转情况。   
求出ω,ω = ΔPhase/Δt = 2πf
求出f并用参考时钟频率替换参考周期(1/fMCLK = Δt),ΔPhase×fMCLK∕2π
AD9833根据这个简单公式来构建输出。一个简单的DDS芯 片便可利用以下三大主要子电路来实现此公式：数控振荡器 (NCO)和相位调制器、SIN ROM以及模数转换器(DAC)。
3.2.3 AD9833频率和相位计算
AD9833包含两个频率寄存器和两个相位寄存器，具体如下所述。

表3.1 AD9833相位寄存器
寄存器	尺寸	描述
FREQ0	28 bits	频率寄存器0，当FSELECT bit=0时，此寄存器将输出频率定义为MCLK频率的一部分
FREQ1	28 bits	频率寄存器1，当FSELECT bit=1时，此寄存器将输出频率定义为MCLK频率的一部分
PHASE0	12 bits	相位偏移寄存器0，当PSELECT bit=0时，此寄存器的内容会增加到相位累加器输出。
PHASE1	12 bits	相位偏移寄存器1，当PSELECT bit=1时，此寄存器的内容会增加到相位累加器输出。

AD9833的模拟输出为： 
其中，FREQREG是载入所选频率寄存器的值。此信号会经过如下相位偏移处理：
 
其中，PHASEREG是所选相位寄存器中包含的值。必须考虑所选输出频率和参考时钟频率之间的关系，以免产生不良的输出异常。
3.2.4 时钟电路
AD9833工作时需要有外部时钟，这里采用的是25M的有源晶振，电路图如图3.6所示。
 
图3.6 25M有源晶振
3.3 程控增益电路
本设计采用数字电位器MAX5487和高速运放THS3001。进行程控放大，MAX5487是一个8位带EEPROM的双通道的数字电位器，可实现0-255级可调。THS3001作为同相放大。闭环增益为420MHz，压摆率为6500-V/µs。输出电流达到100Ma。设定的放大倍数为6倍，电路如图3.7所示。
![这里写图片描述](http://img.blog.csdn.net/20160921214714039) 
图3.7 运放和数字电位器电路图
3.4 滤波电路
本设计使用了无源滤波器，采用5阶巴特沃斯低通滤波器，通频带宽为12.5Mhz，频率响应平滑，成本低廉。使用了filter solutions进行滤波器的设计。电路如图3.8所示
 ![这里写图片描述](http://img.blog.csdn.net/20160921214735039)
图3.8 五阶巴特沃斯低通滤波器
3.5 电源电路
本设计的使用的电源为正负5V，故采用了7805和7905进行供电电路的时间。电路如图3.9所示

 ![这里写图片描述](http://img.blog.csdn.net/20160921214749394)
图3.9 电源电路






3.6 系统连接
本设计采用了ADI的dds芯片ad9833作为信号产生，使用了stc15系统的芯片作为主控芯片，整个系统功耗小，体积小。产生的两路信号方便日常使用，或进行测试使用。只需修改少数地方可以方便扩展到多路。修改程序后可增加FSK等调制模式。方便以后进行升级。相应的系统框图如图3.10
 ![这里写图片描述](http://img.blog.csdn.net/20160921214811149)
图3.10系统连接框图
























4 软件设计
4.1 主程序设计
使用了STC15系列的MCU，1T的时钟周期，两组高速异步串行通信口，内置RC时钟可以下载选择晶振频率。片内有大容量的2048字节的SRAM，3路16位可自动重装载的定时器，本设计采用了两路串口和芯片进行SPI进行通讯，相应的程序框图见下
 ![这里写图片描述](http://img.blog.csdn.net/20160921214828634)
图 4.1 程序框图
4.2 主程序
主程序主要是先进行硬件的初始化，首先初始化串口一和串口二，然后等等屏幕初试化，屏幕显示初始化，设置默认输出进入主循环，等待串口中断。具体程序如下。
void main ()
{
	UartInit();									//串口1初始化 用于和上位机通讯
	UART_Init2();								//串口2初始化 用于和显示屏进行通讯更新数据
	
	delayms(80);								//等待屏幕初始化,建议50ms以上
	UART_Send_END();							//发送一次结束符，清除上电产生的串口杂波数据
	
	AD9833_WaveSeting_two(100000,0,2,90);				//频率初值
	AD9833_WaveSeting_one(100000,0,2,0);				//频率初值
	display_fre(6,10,0);
	display_other(10,0);
	display_other(7,255);
	display_shape_sin(4); 
	display_fre(9,10,0);
	display_other(11,90);
	display_other(8,255);
	display_shape_sin(5);
	
	CopyBothNVtoWR();							//设置放大倍数
	WriteWRA(255);
	WriteWRB(255);
	
//	SendStr("  test ");							 //测试串口一是否工作正常
	vo_diaplay();; 								 //更新屏幕数据
	P1 =0x7f;		
	for(;;)										 //主循环
	{

		if(rx_end_flag == 1)
		{
			ET0=0;
			Data_Process();
			MCU_Answer();
			rx_end_flag=0;
			ET0=1;
			
		}
		if(rx_full_flag == 1)
		{	
			rx_full_flag=0;
		}

	}
}
4.3 串口中断处理
串口一用于与上位机进行通讯接收频率控制字，相位控制字，幅值控制字，波形控制字和通道选择。具体程序如下。
void UART_SER() interrupt 4  using 1             //串行中断服务程序
{

 unsigned char temp; 
                                  
     if(RI)                              //判断是接收中断产生
     {
         RI=0;
        temp = SBUF;                     //标志位清零
        if(n<50)
        {
					if((temp=='a')||(temp=='b')) //end input char
					{
							rx_end_flag = 1;
								switch(temp)
							{
								case 'a': signal_one_flag = 1;break;
								case 'b': signal_two_flag = 1;break;
								default: break;
							}
					}
					else
					{
							rx[n++]=temp;
					} 
					} 
        else
        {
            rx_full_flag=1;
        }         
     }
   if(TI)                               //如果是发送标志位，清零
     {
	 	TI=0;
		busy1 = 0; 
	 }

}
4.4 MCU应答程序
在收到上位机发来的字符串后，对数据进行处理和进行相应的控制。具体的程序如下所示。
void MCU_Answer()               // MCU 应答
{                         // 手动输入频率和占空比以后，单片机做出相应的界面应答
	unsigned char i=0;
	char temp;
	unsigned int temp_h,temp_l;
	temp=CheckCharLegal();
	Short_Delay();
	SendStr("  test ");
	if(temp==1)
	{
		SendStr("Input Success!");
		Send_LNK();
			if(signal_one_flag == 1)				 //accepte signal one
			{
				AD9833_WaveSeting_one(signal_one,0,shape_one,phase_one); //write signal one
				WriteWRA(amp_one);
				Short_Delay();
				Short_Delay();
				temp_h = signal_one/10000;			  //data deal
				temp_l = signal_one%10000;	
				display_fre(6,temp_h,temp_l);
				display_other(10,phase_one);
				display_other(7,amp_one);
				if(shape_one==0) //输出三角波波形
		 			display_shape_tri(4); 
				if(shape_one==1)	//输出方波波形
					display_shape_squ(4);  
				if(shape_one==2)	//输出正弦波形
					display_shape_sin(4);  
				SendStr("Signal A Success!");
				signal_one_flag = 0;
				n = 0;
		}
		else if(signal_two_flag == 1)		  //accepte signal two
		{
			AD9833_WaveSeting_two(signal_two,0,shape_two,phase_two); //write signal two
			Short_Delay();
			WriteWRB(amp_two);
			temp_h = signal_two/10000;
			temp_l = signal_two%10000;	
			display_fre(9,temp_h,temp_l);
			display_other(11,phase_two);
			display_other(8,amp_two);
			if(shape_two==0) //输出三角波波形
	 			display_shape_tri(5); 
			if(shape_two==1)	//输出方波波形
				display_shape_squ(5);  
			if(shape_two==2)	//输出正弦波形
				display_shape_sin(5); 
			SendStr("Signal B Success!");

			signal_two_flag =	0;
			n = 0;
		}
	}
	else if(temp == -1)
	{
		SendStr("Ops, including ILLEGAL character, for conforming...");
		Send_LNK();
		SendStr("Input data: ");
		SendStr(rx);
		Send_LNK();
		SendStr("Error occured, input failure!");
		Send_LNK();
	}
	else if(temp == -2)
	{
		SendStr("Ops, input data ILLEGAL, format: FFFFFFFf or DDd");
		Send_LNK();
		SendStr("Error occured, input failure!");
		Send_LNK();
	}

}
4.5 AD9833驱动程序
AD9833的驱动程序的功能为：向SPI总线发送16个bit数据程序传的形参：1.Freq: 频率值, 0.1 hz - 12Mhz；Freq_SFR: 0 或 1；WaveMode: TRI_WAVE(三角波),SIN_WAVE(正弦波),SQU_WAVE(方波)；Phase : 波形的初相位。具体的代码如下。
void AD9833_WaveSeting_one(double Freq,unsigned int Freq_SFR,unsigned int WaveMode,unsigned int Phase )
{

		int frequence_LSB,frequence_MSB,Phs_data;
		double   frequence_mid,frequence_DATA;
		long int frequence_hex;

		/*********************************计算频率的16进制值***********************************/
		frequence_mid=268435456/25;//适合25M晶振
		//如果时钟频率不为25MHZ，修改该处的频率值，单位MHz ，AD9833最大支持25MHz
		frequence_DATA=Freq;
		frequence_DATA=frequence_DATA/1000000;
		frequence_DATA=frequence_DATA*frequence_mid;
		frequence_hex=frequence_DATA;  //这个frequence_hex的值是32位的一个很大的数字，需要拆分成两个14位进行处理；
		frequence_LSB=frequence_hex; //frequence_hex低16位送给frequence_LSB
		frequence_LSB=frequence_LSB&0x3fff;//去除最高两位，16位数换去掉高位后变成了14位
		frequence_MSB=frequence_hex>>14; //frequence_hex高16位送给frequence_HSB
		frequence_MSB=frequence_MSB&0x3fff;//去除最高两位，16位数换去掉高位后变成了14位

		Phs_data=Phase|0xC000;	//相位值
		AD9833_Write(0x0100); //复位AD9833,即RESET位为1
		AD9833_Write(0x2100); //选择数据一次写入，B28位和RESET位为1

		if(Freq_SFR==0)				  //把数据设置到设置频率寄存器0
		{
		 	frequence_LSB=frequence_LSB|0x4000;
		 	frequence_MSB=frequence_MSB|0x4000;
			 //使用频率寄存器0输出波形
			AD9833_Write(frequence_LSB); //L14，选择频率寄存器0的低14位数据输入
			AD9833_Write(frequence_MSB); //H14 频率寄存器的高14位数据输入
			AD9833_Write(Phs_data);	//设置相位
	     //	AD9833_Write(0x2000); /**设置FSELECT位为0，芯片进入工作状态,频率寄存器0输出波形**/
	    }
		if(Freq_SFR==1)				//把数据设置到设置频率寄存器1
		{
			 frequence_LSB=frequence_LSB|0x8000;
			 frequence_MSB=frequence_MSB|0x8000;
			//使用频率寄存器1输出波形
			AD9833_Write(frequence_LSB); //L14，选择频率寄存器1的低14位输入
			AD9833_Write(frequence_MSB); //H14 频率寄存器1为
			AD9833_Write(Phs_data);	//设置相位
			AD9833_Write(0x0000); //**设置FSELECT位为0，设置FSELECT位为1，即使用频率寄存器1的值，芯片进入工作状态,频率寄存器1输出波形**/
		}

		if(WaveMode==0) //输出三角波波形
		 	AD9833_Write(0x2002); 
		if(WaveMode==1)	//输出方波波形
			AD9833_Write(0x2028); 
		if(WaveMode==2)	//输出正弦波形
			AD9833_Write(0x2000); 

}
4.6 屏幕显示更新程序
屏幕显示通过串口二进行更新，channel取值从0~4.更新频率的格式为n（channel）.val=data;更新电压的格式为t （channel）.txt = “data”。具体的代码如下。
void display_fre(unsigned int channel,unsigned int datah,unsigned int datal)
{
		sprintf(buf,"n%d.val=%d%.4d",channel,datah,datal);
	 	UART_Send_Str2(buf);
	 	UART_Send_END();
}
void display_other(unsigned int channel,unsigned int datah)
{
		sprintf(buf,"n%d.val=%d",channel,datah);

	 	UART_Send_Str2(buf);
	 	UART_Send_END();
		delayms(10);
}
void display_shape_tri(unsigned int channel)
{
		sprintf(buf,"t%d.txt=\"tri\"",channel);
	 	UART_Send_Str2(buf);
	 	UART_Send_END();
		delayms(10);
}
void display_shape_sin(unsigned int channel)
{
		sprintf(buf,"t%d.txt=\"sin\"",channel);
	 	UART_Send_Str2(buf);
	 	UART_Send_END();
		delayms(10);
}
void display_shape_squ(unsigned int channel)
{
		sprintf(buf,"t%d.txt=\"squ\"",channel);
	 	UART_Send_Str2(buf);
	 	UART_Send_END();
		delayms(10);
}
5 系统功能、指标参数
5.1 系统功能
本作品是基于AD9833的双通道信号发生器，由单片机STC152K60S2完成系统的控制功能；幅度控制采用了MAX5487和高速运放THS3001实现。输出还采用了12.5MHz的五阶巴特沃斯无源滤波器。测试表明本作品能产生两路正弦波，方波和三角波三种周期性波形，且能从0MHz到10MHz的稳定输出。
5.2 指标参数 
5.2.1 频率
频率测试采用的是示波器UTD2102，测量了10KHZ到10MHZ的正弦波形，频率10KHz幅度1.78V的信号波形见图5.1，频率5MHz幅度665.28mV的信号波形见图5.2，
频率10MHz幅度64.94mv的信号波形见图5.3.
 ![这里写图片描述](http://img.blog.csdn.net/20160921214912119)
图5.1 频率10KHz幅度1.78V
 ![这里写图片描述](http://img.blog.csdn.net/20160921214922244)
图5.2 频率5MHz幅度665.28mV
 ![这里写图片描述](http://img.blog.csdn.net/20160921214935088)
图5.3 频率10MHz幅度64.94mv
5.2.2 相位
相位测试采用的是示波器UTD2102，测量了AB两个通道的信号相位差分别为0°（图5.4），90°（图5.5），180°（图5.6）的情况如下。
 ![这里写图片描述](http://img.blog.csdn.net/20160921214949823)
图5.4频率101.28KHz 相位差 0°
 
![这里写图片描述](http://img.blog.csdn.net/20160921215000245)图5.5频率101.28KHz 相位差90°
 ![这里写图片描述](http://img.blog.csdn.net/20160921215056840)
图5.6频率101.28KHz 相位差180°
5.2.3 幅值
幅值测试采用的是示波器UTD2102，分别测试了数字电位器控制为50（图5.7），150（图5.8），200（图5.9）时100Khz的正弦信号，波形图如下。
 ![这里写图片描述](http://img.blog.csdn.net/20160921215108942)
图5.7频率100KHz  LV=50
 ![这里写图片描述](http://img.blog.csdn.net/20160921215121114)
图5.8频率100KHz  LV=150
 ![这里写图片描述](http://img.blog.csdn.net/20160921215450272)
图5.9频率100KHz  LV=200

6 结论
本设计基于两片AD9833能能够产生高分辨率、高稳定度的正弦波、三角波、方波信号。与单片机实时控制技术相结合，加上由上位机进行调试，方便在工程中进行测试和使用，在波形选择和频率控制上很方便地实现控制。因此，此设计在各种领域有着广阔的应用前景。
7 总结与体会
通过本次课程设计对这门学科有了深如的学习，对电路也有了深入的学习，在设计过程中，主要做了两方面的设计：一 就是软件的设计。二是对电路的设计。在软件设计中本系统的软件部分主要是利用语言来设计的，并用来实现的所用功能
简单仪器原理与设计的课程是电子类大学生所必修的，是实践教学不可缺少的重要环节。通过课程设计，不仅能提高学生学习智能仪器的兴趣，加深对智能仪器的理解，开阔视野，也能为毕业设计打下良好的基础。学生基本上经历了单片机应用系统开发的全过程，扩大了学生实践的内容，从而取得了较好的教学实践效果。任何特点。收获都要付出巨大的努力，在这个领域里面我几乎是从零开始的，但是我们克服了重重困难，学到了很多东西。
经过四星期的努力，我们终于成功的完成了本次课程设计。再设计过程中我们又很多收获当然也遇到很多困难。譬如说不能把书本上的知识与实践相结合。还有当我们第一次把硬件电路做出来以后就在调试时发现红外对管不工作，原来使我们把电路焊错了电源和地焊反了，当我们修改过后就能正常工作了。
在这次设计的软件部分是用C语言来编程的。由于C语言是近年来在国内外得到迅速推广应用的一种语言。C语言功能丰富，表达能力强，使用灵活方便，应用面广，目标程序效率高，可移植性好，既具有高级语言的优点，又具有低级语言的许多特点。通过这次C语言程序设计我们更加了解了C语言。在C语言程序设计的过程中我们知道了以前学的很多不足，有些地方看不懂也不知道怎么去设计，但是在设计过程中也学习了很多，掌握了自己以前没有学好的知识，不过这也给自己敲响了警钟，在学习中不可以浮于表面，要想学好每一门课程就必须踏实。
本次设计增强了我们查阅资料的方法和技巧，更是大大的提高了我们自学的能力，同时也增强了我们的动手能力。
通过本次课程设计，我们在对这门技术上有了更深刻的认识，也从实践中去感受到了技术给我们设计带来的改变与进步。我们不仅基本掌握了软件的使用，还对电子设计的思路有了更多的认识。
在本次课程设计过程中，我们三个人一起查资料、一起讨论、一起交流，最终我们决定了设计方案并成功完成设计，这些都培养了我们的团结合作精神，这次设计让我们受益匪浅。
8 致谢
本次课程设计我们遇到了许多问题，在老师的指导下，我们小组同学积极思考和讨论，完成了此次课程设计。通过这次设计我们受益匪浅，学到了很多东西。在此我们要感谢学院提供了这次课程设计的机会；感谢在设计中给予我许多帮助的老师，特别要感谢阳小明和李天倩两位老师，在我们的设计过程中，他们至始至终地给予我们悉心的指导，从而使我们的设计顺利完成。同时也要感谢小组内的各位同学，感谢全组同学能够做到互相学习、团结一致共同战胜难点。















9 参考文献
[1] 谭浩强. C语言程序设计（第三版）[J].北京：清华大学出版社,2005
[2]张毅刚、彭喜元.单片机原理及应用[M].北京：高等教育出版社，2003
[3] 张海兵、李敏.PROTEL电路设计实例与分析[J]. 北京：人民邮电出版社，2005
[4] 李春葆、金晶.C语言程序设计辅导[M].北京:清华大学出版社,2007
[5] 杨将新、李华军.单片机程序设计及应用（第三版）[M]. 北京：电子工业出版社，2006
[6] 鲁捷、焦振宇.PROTEL 2004 电路设计[M]. 北京：清华大学出版社，2006
[7]康光华 陈大钦 电子技术基础模拟部分（第四版）[M].高等教育出版社.1987
[8]谢自美 主编．电子线路设计.实验.测试（第二版）[M]．华中理工大学出版社，2005
[9] 王为青，邱文勋. 51单片机开发案例精选[J].人民邮电出版社，2001，(5)：45-47
[10] 边海龙，孙永奎. 单片机开发与典型工程项目实例详解[J].电子工业出版社，2008 [11] 康光华、邹寿彬.电子技术基础数字部分（第五版）[M]. 北京：高等教育出版社，2006
[12]谢维成，刘勇.微机原理与接口技术[M].华中科技大学出版社，2009
[13]张毅刚.单片机原理及应用[M].高等教育出版社，2003














![这里写图片描述](http://img.blog.csdn.net/20160921215702175)
附录一 相关设计图
 ![这里写图片描述](http://img.blog.csdn.net/20160921220153572)
图一 DDS电路
 
![这里写图片描述](http://img.blog.csdn.net/20160921215712960)
图二  STC15最小系统
![这里写图片描述](http://img.blog.csdn.net/20160921215729801)
图三  DDS电路PCB





![这里写图片描述](http://img.blog.csdn.net/20160921215744098)
图三  实物图

 ![这里写图片描述](http://img.blog.csdn.net/20160921215806317)
图四  屏幕显示
附录二 相关设计软件
 ![这里写图片描述](http://img.blog.csdn.net/20160921215817567)
图五 主函数
